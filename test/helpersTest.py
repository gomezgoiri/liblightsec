'''
Created on 26/08/2014

@author: Aitor Gomez Goiri
'''

import unittest
from Crypto.Hash.SHA256 import SHA256Hash
from lightsec.helpers import BaseStationHelper, SensorHelper, UserHelper
from lightsec.tools.key_derivation import KeyDerivationFunctionFactory, Nist800
from lightsec.tools.encryption import AESCTRCipher


class HelpersTest(unittest.TestCase):
    
    def setUp(self):
        self.kdf_factory = KeyDerivationFunctionFactory( Nist800, SHA256Hash(), 256 ) # 512 ) 
        self.base_station = BaseStationHelper( self.kdf_factory )
        self.base_station.install_secret("sensor1", "authms1", "encms1")
    
    def test_encryption(self):
        id_user = "user1"
        stuff = self.base_station.create_keys( id_user, "sensor1", 10 )
        sensor = SensorHelper( self.kdf_factory, "authms1", "encms1",
                                    SHA256Hash, AESCTRCipher )
        
        user = UserHelper("sensor1", stuff["kenc"], AESCTRCipher, stuff["kauth"],
                          SHA256Hash, id_user, stuff["a"], stuff["init_time"], stuff["exp_time"] )
        first_message = "test message"
        ciphertext = user.encrypt(first_message)
        
        # test that same keys are generated by the base station and the sensor
        kenc, kauth = sensor.create_keys( id_user, stuff["a"], stuff["init_time"], stuff["exp_time"], user.initial_counter )
        self.assertSequenceEqual( kenc, stuff["kenc"] )
        self.assertSequenceEqual( kauth, stuff["kauth"] )
        
        # test that the sensor is now able to understand the first message sent by the user
        deciphertext = sensor.decrypt( id_user, ciphertext )
        # TODO TODO TODO understand why encrypt returns the same
        #recipheredtext = sensor.encrypt( id_user, ciphertext )
        self.assertSequenceEqual(deciphertext, first_message)
        
        # test that the sensor is able to authenticate the message
        mactext = user.mac( first_message )
        self.assertTrue( sensor.msg_is_authentic( deciphertext, mactext, id_user, stuff["a"], stuff["init_time"], user.initial_counter ) )
        
        # test that the user understands the sensor's response
        first_response = "this is a super important response"
        cipherresp = sensor.encrypt( id_user, first_response )
        decipherresp = user.decrypt( cipherresp )
        self.assertSequenceEqual(decipherresp, first_response)
        
        # test that the user can validate the response received
        respmac = sensor.mac( first_response, id_user )
        self.assertTrue( user.msg_is_authentic(decipherresp, respmac) )


if __name__ == "__main__":
    #import sys;sys.argv = ['', 'Test.testName']
    unittest.main()